using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace AlgorithmsComputabilityProject
{
    public class ConsoleMenu
    {
        private Stopwatch stopwatch = new Stopwatch();
        private List<int> ChosenSizes { get; set; } = new List<int>();
        private List<Matrix> GeneratedMatrices { get; set; } = new List<Matrix>();
        private Dictionary<string, Matrix> CalculatedMatrices { get; set; } = new Dictionary<string, Matrix>();
        private bool IsExactAlgorithmApplicable
        {
            get
            {
                return ChosenSizes[0] < 11 && ChosenSizes[1] < 11;
            }
        }

        public void RunConsoleMenu(string[] args)
        {
            try
            {
                bool flag = true;
                while (flag)
                {
                    Console.WriteLine("Press a key to choose the action:");
                    Console.WriteLine("1 - Run algorithms on random graphs generated by the program");
                    Console.WriteLine("2 - Run algorithms on graphs specified in the input file");
                    Console.WriteLine("q - Quit the application");
                    char key = Console.ReadKey().KeyChar;
                    Console.WriteLine();

                    switch (key)
                    {
                        case '1':
                            DisplayOptionsForRandomGraphs();
                            break;
                        case '2':
                            DisplayOptionsForSpecifiedGraphs();
                            break;
                        case 'q':
                            flag = false;
                            Console.WriteLine();
                            break;
                        default:
                            Console.WriteLine("\nInvalid option selected.\n");
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DisplayException(ex);
                Console.WriteLine("Press any key to exit.");
                Console.ReadKey();
            }
        }

        private void DisplayOptionsForRandomGraphs()
        {
            bool flag = true;
            while (flag)
            {
                if (ChosenSizes.Count < 2)
                {
                    Console.WriteLine("Note: If size of a graph is bigger than 10, only approximate algorithms will be available.");
                    Console.WriteLine("Please enter the size of the first graph and confirm by pressing enter.");

                    ChosenSizes.Add(ReadInteger());
                    Console.WriteLine("Please enter the size of the second graph and confirm by pressing enter.");
                    ChosenSizes.Add(ReadInteger());
                    Console.WriteLine("Generating graphs...");

                    GeneratedMatrices.Add(GraphGenerator.GetRandomMatrix(ChosenSizes[0]));
                    GeneratedMatrices.Add(GraphGenerator.GetRandomMatrix(ChosenSizes[1]));
                    Console.Write("Graphs generated. ");
                }

                Console.WriteLine("Please press a key to choose an option:");
                Console.WriteLine("1 - Print graphs");
                Console.WriteLine("2 - Show the Approximate Maximal Common Subgraph");
                Console.WriteLine("3 - Show the Approximate Minimal Common Supergraph");
                if (ChosenSizes[0] < 11 && ChosenSizes[1] < 11)
                {
                    Console.WriteLine("4 - Show the Exact Maximal Common Subgraph");
                    Console.WriteLine("5 - Show the Exact Minimal Common Supergraph");
                }
                Console.WriteLine("b - Go back");
                char key = Console.ReadKey().KeyChar;
                Console.WriteLine();

                switch (key)
                {
                    case '1':
                        GeneratedMatrices[0].PrintNextTo(GeneratedMatrices[1]);
                        break;
                    case '2':
                        if (!CalculatedMatrices.ContainsKey("ApproximateMaximalSubGraph"))
                        {
                            Console.WriteLine("Calculating the solution...");
                            stopwatch.Start();
                            Matrix maxCommonSubgraph = Algorithm.FindMaximalSubGraphApproximate(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            CalculatedMatrices.Add("ApproximateMaximalSubGraph", maxCommonSubgraph);
                        }
                        GeneratedMatrices[0].PrintNextTo(GeneratedMatrices[1]);
                        CalculatedMatrices["ApproximateMaximalSubGraph"].Print("Maximal Common Subgraph (Approximate)");
                        break;
                    case '3':
                        if (!CalculatedMatrices.ContainsKey("ApproximateMinimalSuperGraph"))
                        {
                            Console.WriteLine("Calculating the solution...");
                            stopwatch.Start();
                            Matrix minCSupergraph = Algorithm.FindMinimalSuperGraphApproximate(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            CalculatedMatrices.Add("ApproximateMinimalSuperGraph", minCSupergraph);
                        }
                        GeneratedMatrices[0].PrintNextTo(GeneratedMatrices[1]);
                        CalculatedMatrices["ApproximateMinimalSuperGraph"].Print("Minimal Common Supergraph (Approximate)");
                        break;
                    case '4':
                        if (IsExactAlgorithmApplicable)
                        {
                            if (!CalculatedMatrices.ContainsKey("ExactMaximalSubGraph"))
                            {
                                Console.WriteLine("Calculating the solution...");
                                stopwatch.Start();
                                Matrix exactMCSubgraph = Algorithm.FindMaximalSubGraph(GeneratedMatrices[0], GeneratedMatrices[1]);
                                stopwatch.Stop();
                                Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                                CalculatedMatrices.Add("ExactMaximalSubGraph", exactMCSubgraph);
                            }
                            GeneratedMatrices[0].PrintNextTo(GeneratedMatrices[1]);
                            CalculatedMatrices["ExactMaximalSubGraph"].Print("Maximal Common Subgraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case '5':
                        if (IsExactAlgorithmApplicable)
                        {
                            if (!CalculatedMatrices.ContainsKey("ExactMinimalSuperGraph"))
                            {
                                Console.WriteLine("Calculating the solution...");
                                stopwatch.Start();
                                Matrix exactMCSupergraph = Algorithm.FindMinimalSuperGraph(GeneratedMatrices[0], GeneratedMatrices[1]);
                                stopwatch.Stop();
                                Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                                CalculatedMatrices.Add("ExactMinimalSuperGraph", exactMCSupergraph);
                            }
                            GeneratedMatrices[0].PrintNextTo(GeneratedMatrices[1]);
                            CalculatedMatrices["ExactMinimalSuperGraph"].Print("Minimal Common Supergraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case 'b':
                        flag = false;
                        ChosenSizes.Clear();
                        GeneratedMatrices.Clear();
                        CalculatedMatrices.Clear();
                        Console.WriteLine();
                        break;
                    default:
                        Console.WriteLine("\nInvalid option selected.\n");
                        break;
                }
            }
        }

        private static int ReadInteger()
        {
            int size = 0;
            while (size < 2)
            {
                string input = Console.ReadLine();
                while (!Int32.TryParse(input, out size))
                {
                    Console.WriteLine("Please provide a valid value for size:");
                    input = Console.ReadLine();
                }
                if (size < 2)
                {
                    Console.WriteLine("The graph should have at least 2 vertices. Please provide a valid value for size:");
                }
            }
            return size;
        }

        private void DisplayOptionsForSpecifiedGraphs()
        {
            Console.WriteLine("Note: If size of a graph is bigger than 10, only approximate algorithms will be available.");
            Console.WriteLine("Please write global path to the file with matrices:");

            string input = Console.ReadLine();

            while (!File.Exists(input))
            {
                Console.WriteLine("File wasn't found! Please supply correct global path or press 1 to go back.");
                input = Console.ReadLine();
                if (input == "1")
                {
                    return;
                }
            }

            try
            {
                (Matrix m1, Matrix m2) = FileReader.Read(input);
                GeneratedMatrices.Add(m1);
                GeneratedMatrices.Add(m2);
                ChosenSizes.Add(m1.VerticesNumber);
                ChosenSizes.Add(m2.VerticesNumber);
            }
            catch
            {
                Console.WriteLine("File deserialization went wrong. Going back to main menu");
                return;
            }
            Console.WriteLine();

            bool flag = true;
            while (flag)
            {
                Console.WriteLine("Graphs deserialized! Please press a key to choose an option:");
                Console.WriteLine("1 - Print the first graph");
                Console.WriteLine("2 - Show the Approximate Maximal Common Subgraph");
                Console.WriteLine("3 - Show the Approximate Minimal Common Supergraph");
                if (ChosenSizes[0] < 11 && ChosenSizes[1] < 11)
                {
                    Console.WriteLine("4 - Show the Exact Maximal Common Subgraph");
                    Console.WriteLine("5 - Show the Exact Minimal Common Supergraph");
                }
                Console.WriteLine("b - Go back (this option will reset the graphs)");
                char key = Console.ReadKey().KeyChar;
                Console.WriteLine();

                switch (key)
                {
                    case '1':
                        GeneratedMatrices[0].PrintNextTo(GeneratedMatrices[1]);
                        break;
                    case '2':
                        if (!CalculatedMatrices.ContainsKey("ApproximateMaximalSubGraph"))
                        {
                            Console.WriteLine("Calculating the solution...");
                            stopwatch.Start();
                            Matrix maxCSubgraph = Algorithm.FindMaximalSubGraphApproximate(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            CalculatedMatrices.Add("ApproximateMaximalSubGraph", maxCSubgraph);
                        }
                        CalculatedMatrices["ApproximateMaximalSubGraph"].Print("Maximal Common Subgraph (Approximate)");
                        break;
                    case '3':
                        if (!CalculatedMatrices.ContainsKey("ApproximateMinimalSuperGraph"))
                        {
                            Console.WriteLine("Calculating the solution...");
                            stopwatch.Start();
                            Matrix minCSupergraph = Algorithm.FindMinimalSuperGraphApproximate(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            CalculatedMatrices.Add("ApproximateMinimalSuperGraph", minCSupergraph);
                        }
                        CalculatedMatrices["ApproximateMinimalSuperGraph"].Print("Minimal Common Supergraph (Approximate)");
                        break;
                    case '4':
                        if (IsExactAlgorithmApplicable)
                        {
                            if (!CalculatedMatrices.ContainsKey("ExactMaximalSubGraph"))
                            {
                                Console.WriteLine("Calculating the solution...");
                                stopwatch.Start();
                                Matrix exactMCSubgraph = Algorithm.FindMaximalSubGraph(GeneratedMatrices[0], GeneratedMatrices[1]);
                                stopwatch.Stop();
                                Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                                CalculatedMatrices.Add("ExactMaximalSubGraph", exactMCSubgraph);
                            }
                            CalculatedMatrices["ExactMaximalSubGraph"].Print("Maximal Common Subgraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case '5':
                        if (IsExactAlgorithmApplicable)
                        {
                            if (!CalculatedMatrices.ContainsKey("ExactMinimalSuperGraph"))
                            {
                                Console.WriteLine("Calculating the solution...");
                                stopwatch.Start();
                                Matrix exactMCSupergraph = Algorithm.FindMinimalSuperGraph(GeneratedMatrices[0], GeneratedMatrices[1]);
                                stopwatch.Stop();
                                Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                                CalculatedMatrices.Add("ExactMinimalSuperGraph", exactMCSupergraph);
                            }
                            CalculatedMatrices["ExactMinimalSuperGraph"].Print("Minimal Common Supergraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case 'b':
                        ChosenSizes.Clear();
                        GeneratedMatrices.Clear();
                        CalculatedMatrices.Clear();
                        flag = false;
                        Console.WriteLine();
                        break;
                    default:
                        Console.WriteLine("\nInvalid option selected.\n");
                        break;
                }
            }
        }

        private static void DisplayException(Exception ex)
        {
            Console.WriteLine("The application terminated with an error.");
            Console.WriteLine(ex.Message);
            while (ex.InnerException != null)
            {
                Console.WriteLine("\t* {0}", ex.InnerException.Message);
                ex = ex.InnerException;
            }
        }

        private string GetElapsedTime(TimeSpan ts)
        {
            string elapsedTime = String.Format("{0:00}h {1:00}min {2:00}s {3:000}ms", ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds);
            return elapsedTime;
        }
    }
}
