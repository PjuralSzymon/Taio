using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace AlgorithmsComputabilityProject
{
    public class ConsoleMenu
    {
        private Stopwatch stopwatch = new Stopwatch();
        private List<int> ChosenSizes { get; set; } = new List<int>();
        private List<Matrix> GeneratedMatrices { get; set; } = new List<Matrix>();
        private bool IsExactAlgorithmApplicable
        {
            get
            {
                return ChosenSizes[0] < 11 && ChosenSizes[1] < 11;
            }
        }

        public void RunConsoleMenu(string[] args)
        {
            try
            {
                bool flag = true;
                while (flag)
                {
                    Console.WriteLine("Press a key to choose the action:");
                    Console.WriteLine("1 - Run algorithms on random graphs generated by the program");
                    Console.WriteLine("2 - Run algorithms on graphs specified in the input file");
                    Console.WriteLine("q - Quit the application");
                    char key = Console.ReadKey().KeyChar;
                    Console.WriteLine();

                    switch (key)
                    {
                        case '1':
                            DisplayOptionsForRandomGraphs();
                            break;
                        case '2':
                            DisplayOptionsForSpecifiedGraphs();
                            break;
                        case 'q':
                            flag = false;
                            Console.WriteLine();
                            break;
                        default:
                            Console.WriteLine("\nInvalid option selected.\n");
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DisplayException(ex);
                Console.WriteLine("Press any key to exit.");
                Console.ReadKey();
            }
        }

        private void DisplayOptionsForRandomGraphs()
        {
            bool flag = true;
            while (flag)
            {
                if (ChosenSizes.Count < 2)
                {
                    Console.WriteLine("Note: If size of a graph is bigger than 10, only approximate algorithms will be available.");
                    Console.WriteLine("Please enter the size of the first graph and confirm by pressing enter.");

                    ChosenSizes.Add(ReadInteger());
                    Console.WriteLine("Please enter the size of the second graph and confirm by pressing enter.");
                    ChosenSizes.Add(ReadInteger());
                    Console.WriteLine("Generating graphs...");

                    GeneratedMatrices.Add(GraphGenerator.GetRandomMatrix(ChosenSizes[0]));
                    GeneratedMatrices.Add(GraphGenerator.GetRandomMatrix(ChosenSizes[1]));
                    Console.Write("Graphs generated. ");
                }

                Console.WriteLine("Please press a key to choose an option:");
                Console.WriteLine("1 - Print graphs");
                Console.WriteLine("2 - Show the Approximate Maximal Common Subgraph");
                Console.WriteLine("3 - Show the Approximate Minimal Common Supergraph");
                if (ChosenSizes[0] < 11 && ChosenSizes[1] < 11)
                {
                    Console.WriteLine("4 - Show the Exact Maximal Common Subgraph");
                    Console.WriteLine("5 - Show the Exact Minimal Common Supergraph");
                }
                Console.WriteLine("b - Go back");
                char key = Console.ReadKey().KeyChar;
                Console.WriteLine();

                switch (key)
                {
                    case '1':
                        Matrix.PrintGraphs(GeneratedMatrices[0], GeneratedMatrices[1]);
                        break;
                    case '2':
                        Console.WriteLine("Calculating the solution...");
                        stopwatch.Start();
                        var maxSubgraph = ConsoleAlgorithm.FindMaximalSubGraphApproximateConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                        stopwatch.Stop();
                        Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                        var printInfo1 = ConsoleAlgorithm.MarkCommonSubgraphEdges(maxSubgraph);
                        Matrix.PrintResults(printInfo1.Item1, printInfo1.Item2, printInfo1.Item3, "Max Common Subgraph (Approximate)");
                        break;
                    case '3':
                        Console.WriteLine("Calculating the solution...");
                        stopwatch.Start();
                        var minSupergraph = ConsoleAlgorithm.FindMinimalSuperGraphApproximateConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                        stopwatch.Stop();
                        Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                        var printInfo2 = ConsoleAlgorithm.MarkCommonSupergraphEdges(minSupergraph);
                        Matrix.PrintResults(printInfo2.Item1, printInfo2.Item2, printInfo2.Item3, "Min Common Supergraph (Approximate)");
                        break;
                    case '4':
                        if (IsExactAlgorithmApplicable)
                        {
                            Console.WriteLine("\nCalculating the solution...");
                            stopwatch.Start();
                            var results = ConsoleAlgorithm.FindMaximalSubGraphConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            var printInfo = ConsoleAlgorithm.MarkCommonSubgraphEdges(results);
                            Matrix.PrintResults(printInfo.Item1, printInfo.Item2, printInfo.Item3, "Max Common Subgraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case '5':
                        if (IsExactAlgorithmApplicable)
                        {
                            Console.WriteLine("Calculating the solution...");
                            stopwatch.Start();
                            var results = ConsoleAlgorithm.FindMinimalSuperGraphConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            var printInfo = ConsoleAlgorithm.MarkCommonSupergraphEdges(results);
                            Matrix.PrintResults(printInfo.Item1, printInfo.Item2, printInfo.Item3, "Min Common Supergraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case 'b':
                        flag = false;
                        ChosenSizes.Clear();
                        GeneratedMatrices.Clear();
                        stopwatch.Reset();
                        Console.WriteLine();
                        break;
                    default:
                        Console.WriteLine("\nInvalid option selected.\n");
                        break;
                }
            }
        }

        private static int ReadInteger()
        {
            int size = 0;
            while (size < 3)
            {
                string input = Console.ReadLine();
                while (!Int32.TryParse(input, out size))
                {
                    Console.WriteLine("Please provide a valid value for size:");
                    input = Console.ReadLine();
                }
                if (size < 3)
                {
                    Console.WriteLine("The graph should have at least 3 vertices. Please provide a valid value for size:");
                }
            }
            return size;
        }

        private void DisplayOptionsForSpecifiedGraphs()
        {
            Console.WriteLine("Note: If size of a graph is bigger than 10, only approximate algorithms will be available.");
            Console.WriteLine("Please write global path to the file with matrices:");

            string input = Console.ReadLine();

            while (!File.Exists(input))
            {
                Console.WriteLine("File wasn't found! Please supply correct global path or press 1 to go back.");
                input = Console.ReadLine();
                if (input == "1")
                {
                    return;
                }
            }

            try
            {
                (Matrix m1, Matrix m2) = FileReader.Read(input);
                GeneratedMatrices.Add(m1);
                GeneratedMatrices.Add(m2);
                ChosenSizes.Add(m1.VerticesNumber);
                ChosenSizes.Add(m2.VerticesNumber);
            }
            catch
            {
                Console.WriteLine("File deserialization went wrong. Going back to main menu");
                return;
            }
            Console.WriteLine();

            bool flag = true;
            while (flag)
            {
                Console.WriteLine("Graphs deserialized! Please press a key to choose an option:");
                Console.WriteLine("1 - Print the first graph");
                Console.WriteLine("2 - Show the Approximate Maximal Common Subgraph");
                Console.WriteLine("3 - Show the Approximate Minimal Common Supergraph");
                if (ChosenSizes[0] < 11 && ChosenSizes[1] < 11)
                {
                    Console.WriteLine("4 - Show the Exact Maximal Common Subgraph");
                    Console.WriteLine("5 - Show the Exact Minimal Common Supergraph");
                }
                Console.WriteLine("b - Go back (this option will reset the graphs)");
                char key = Console.ReadKey().KeyChar;
                Console.WriteLine();

                switch (key)
                {
                    case '1':
                        Matrix.PrintGraphs(GeneratedMatrices[0], GeneratedMatrices[1]);
                        break;
                    case '2':
                        Console.WriteLine("Calculating the solution...");
                        stopwatch.Start();
                        var maxSubgraph = ConsoleAlgorithm.FindMaximalSubGraphApproximateConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                        stopwatch.Stop();
                        Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                        var printInfo1 = ConsoleAlgorithm.MarkCommonSubgraphEdges(maxSubgraph);
                        Matrix.PrintResults(printInfo1.Item1, printInfo1.Item2, printInfo1.Item3, "Max Common Subgraph (Approximate)");
                        break;
                    case '3':
                        Console.WriteLine("Calculating the solution...");
                        stopwatch.Start();
                        var minSupergraph = ConsoleAlgorithm.FindMinimalSuperGraphApproximateConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                        stopwatch.Stop();
                        Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                        var printInfo2 = ConsoleAlgorithm.MarkCommonSupergraphEdges(minSupergraph);
                        Matrix.PrintResults(printInfo2.Item1, printInfo2.Item2, printInfo2.Item3, "Min Common Supergraph (Approximate)");
                        break;
                    case '4':
                        if (IsExactAlgorithmApplicable)
                        {
                            Console.WriteLine("\nCalculating the solution...");
                            stopwatch.Start();
                            var exactSubgraph = ConsoleAlgorithm.FindMaximalSubGraphConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            var printInfo = ConsoleAlgorithm.MarkCommonSubgraphEdges(exactSubgraph);
                            Matrix.PrintResults(printInfo.Item1, printInfo.Item2, printInfo.Item3, "Max Common Subgraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case '5':
                        if (IsExactAlgorithmApplicable)
                        {
                            Console.WriteLine("Calculating the solution...");
                            stopwatch.Start();
                            var exactSupergraph = ConsoleAlgorithm.FindMinimalSuperGraphConsole(GeneratedMatrices[0], GeneratedMatrices[1]);
                            stopwatch.Stop();
                            Console.WriteLine("Calculation time: " + GetElapsedTime(stopwatch.Elapsed));
                            var printInfo = ConsoleAlgorithm.MarkCommonSupergraphEdges(exactSupergraph);
                            Matrix.PrintResults(printInfo.Item1, printInfo.Item2, printInfo.Item3, "Min Common Supergraph (Exact)");
                        }
                        else Console.WriteLine("Not applicable for graphs bigger than 10 vertices");
                        break;
                    case 'b':
                        ChosenSizes.Clear();
                        GeneratedMatrices.Clear();
                        stopwatch.Reset();
                        flag = false;
                        Console.WriteLine();
                        break;
                    default:
                        Console.WriteLine("\nInvalid option selected.\n");
                        break;
                }
            }
        }

        private static void DisplayException(Exception ex)
        {
            Console.WriteLine("The application terminated with an error.");
            Console.WriteLine(ex.Message);
            while (ex.InnerException != null)
            {
                Console.WriteLine("\t* {0}", ex.InnerException.Message);
                ex = ex.InnerException;
            }
        }

        private string GetElapsedTime(TimeSpan ts)
        {
            string elapsedTime = String.Format("{0:00}min {1:00}s {2:000}ms", ts.Minutes, ts.Seconds, ts.Milliseconds);
            return elapsedTime;
        }
    }
}
